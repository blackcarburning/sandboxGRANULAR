<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Granular LFO</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --panel-bg: #1e1e32;
            --accent: #00d4ff;
            --accent-dim: rgba(0, 212, 255, 0.1);
            --lfo-color: #ffd700;
            --lfo-dim: rgba(255, 215, 0, 0.1);
            --rec-color: #ff3366;
            --text-main: #cecece;
            --text-dim: #888;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-main);
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* No scroll on body */
            position: fixed; /* Lock bounce */
            user-select: none;
            -webkit-user-select: none;
        }

        /* Overlays */
        .overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 1000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #orientation-overlay { display: none; }
        @media screen and (orientation: portrait) { 
            #orientation-overlay { display: flex; } 
            .main-ui { display: none !important; }
        }

        button.start-btn {
            background: var(--accent); color: #000; padding: 15px 40px; 
            border: none; border-radius: 30px; font-size: 16px; font-weight: bold; margin-top: 20px;
        }

        /* Main Grid */
        .main-ui {
            display: flex; flex-direction: column; height: 100%; padding: 4px; gap: 4px;
        }

        /* Top Area: Rec + LFO + Controls */
        .top-deck {
            flex: 1; 
            display: flex; 
            gap: 4px; 
            min-height: 0; /* Critical for nested scroll */
        }

        /* Left Sidebar: Rec & LFO Master */
        .sidebar {
            width: 160px;
            display: flex; flex-direction: column; gap: 4px;
        }

        .panel {
            background: var(--panel-bg); border: 1px solid #333; border-radius: 6px; padding: 6px;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .rec-panel { flex: 0 0 auto; height: 110px; }
        .lfo-panel { flex: 0 0 auto; height: 90px; border-color: #554400; }

        .panel-header {
            font-size: 10px; font-weight: bold; color: var(--accent); text-transform: uppercase; margin-bottom: 4px;
            display: flex; justify-content: space-between;
        }
        .lfo-panel .panel-header { color: var(--lfo-color); }

        .btn-row { display: flex; gap: 4px; margin-bottom: 4px; }
        .btn-std { 
            flex: 1; background: #333; color: #fff; border: none; border-radius: 3px; 
            font-size: 10px; padding: 6px 0; font-weight: bold; 
        }
        #recordBtn { background: #502020; color: #ffadad; }
        #recordBtn.recording { background: var(--rec-color); color: #fff; animation: flash 1s infinite; }
        @keyframes flash { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        canvas { background: #000; width: 100%; height: 35px; border-radius: 3px; border: 1px solid #333; }
        .status-text { font-size: 9px; color: #666; text-align: center; margin-top: 2px; height: 12px; overflow: hidden;}

        /* LFO Controls in Sidebar */
        .lfo-row { display: flex; align-items: center; gap: 4px; margin-bottom: 4px; }
        .lfo-row label { font-size: 9px; color: #888; width: 30px; }
        .lfo-row select { background: #222; color: var(--lfo-color); border: none; font-size: 10px; flex: 1; }
        .lfo-mini-slider { flex: 1; height: 15px; display: flex; flex-direction: column; justify-content: center; }
        .lfo-mini-slider input { width: 100%; }
        
        /* Main Controls Grid */
        .controls-grid {
            flex: 1;
            background: var(--panel-bg); border: 1px solid #333; border-radius: 6px; padding: 4px;
            overflow-y: auto; 
            -webkit-overflow-scrolling: touch;
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4 Columns */
            grid-auto-rows: min-content;
            gap: 4px;
            align-content: start;
        }

        /* Individual Control Strip */
        .control-strip {
            background: rgba(0,0,0,0.2); border-radius: 4px; padding: 4px;
            display: flex; flex-direction: column; gap: 2px;
        }
        .control-strip.hl { background: var(--accent-dim); }

        .strip-header { display: flex; justify-content: space-between; align-items: center; height: 14px; }
        .strip-label { font-size: 9px; font-weight: 600; color: #aaa; white-space: nowrap; }
        .strip-val { font-size: 9px; color: var(--accent); font-family: monospace; }
        
        .strip-body { display: flex; align-items: center; gap: 2px; height: 20px; }
        
        /* Range Slider */
        input[type=range] {
            -webkit-appearance: none; background: transparent; width: 100%; flex: 1;
        }
        input[type=range]::-webkit-slider-runnable-track {
            height: 3px; background: #444; border-radius: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; 
            background: var(--accent); margin-top: -5px; border: 1px solid #000;
        }
        /* LFO colored sliders */
        .lfo-slider::-webkit-slider-thumb { background: var(--lfo-color); }

        /* Small Toggle Buttons */
        .tgl-btn {
            width: 16px; height: 16px; border: 1px solid #444; background: #222; 
            color: #666; font-size: 8px; font-weight: bold; border-radius: 3px;
            display: flex; align-items: center; justify-content: center; padding: 0;
        }
        .tgl-btn.active-mod { background: var(--lfo-color); color: #000; border-color: var(--lfo-color); }
        .tgl-btn.active-inv { background: #ff4444; color: #fff; border-color: #ff4444; }

        /* Keyboard */
        .keyboard-area {
            height: 100px; /* Fixed height */
            flex-shrink: 0;
            background: var(--panel-bg); border-radius: 6px; border: 1px solid #333;
            display: flex; justify-content: center; padding: 0 10px;
            position: relative; overflow: hidden;
        }
        .keys-container {
            display: flex; position: relative; width: 100%; height: 100%;
        }
        .key-white {
            flex: 1; background: #ddd; border: 1px solid #999; border-top: none; 
            border-radius: 0 0 4px 4px; margin: 0 1px; z-index: 1;
            display: flex; align-items: flex-end; justify-content: center; 
            padding-bottom: 5px; font-size: 9px; color: #444; font-weight: bold;
        }
        .key-black {
            position: absolute; width: 5%; height: 60%; background: #111; z-index: 2;
            border-radius: 0 0 3px 3px; border: 1px solid #000; top: 0;
        }
        .key-white.active { background: var(--accent); transform: scaleY(0.98); transform-origin: top; }
        .key-black.active { background: var(--accent); }

        /* Black Key Positions (Approximated for 14 white keys) */
        /* 14 white keys. 1 slot = 100/14 = 7.14% */
        /* Black keys sit between white keys. */
        .bk-1 { left: 5%; }   /* C#1 */
        .bk-2 { left: 12%; }  /* D#1 */
        .bk-3 { left: 26.5%; } /* F#1 */
        .bk-4 { left: 33.5%; } /* G#1 */
        .bk-5 { left: 40.5%; } /* A#1 */
        .bk-6 { left: 55%; }  /* C#2 */
        .bk-7 { left: 62%; }  /* D#2 */
        .bk-8 { left: 76.5%; } /* F#2 */
        .bk-9 { left: 83.5%; } /* G#2 */
        .bk-10 { left: 90.5%; } /* A#2 */

    </style>
</head>
<body>

    <div id="orientation-overlay" class="overlay">
        <h1 style="color:var(--accent)">Rotate Device</h1>
    </div>

    <div id="start-overlay" class="overlay">
        <h1 style="color:var(--accent)">Granular LFO</h1>
        <p style="color:#aaa; font-size: 12px; margin-top: 10px">Turn off Silent Mode</p>
        <button id="start-btn" class="start-btn">START</button>
    </div>

    <div class="main-ui">
        <div class="top-deck">
            <!-- Sidebar -->
            <div class="sidebar">
                <div class="panel rec-panel">
                    <div class="panel-header"><span>Audio In</span></div>
                    <div class="btn-row">
                        <button id="recordBtn" class="btn-std">REC MIC</button>
                        <button id="clearBtn" class="btn-std">CLR</button>
                    </div>
                    <canvas id="waveCanvas"></canvas>
                    <div id="status" class="status-text">Ready</div>
                </div>

                <div class="panel lfo-panel">
                    <div class="panel-header"><span>LFO Master</span> <span id="lfoValDisplay" style="color:var(--lfo-color)"></span></div>
                    <div class="lfo-row">
                        <select id="lfoShape">
                            <option value="sine">Sine</option>
                            <option value="saw">Saw</option>
                            <option value="square">Square</option>
                            <option value="tri">Tri</option>
                        </select>
                    </div>
                    <div class="lfo-row">
                        <label>Rate</label>
                        <div class="lfo-mini-slider">
                            <input type="range" id="lfoRate" class="lfo-slider" min="10" max="400" value="120">
                        </div>
                    </div>
                    <div class="lfo-row">
                        <label>Dpth</label>
                        <div class="lfo-mini-slider">
                            <input type="range" id="lfoDepth" class="lfo-slider" min="0" max="100" value="50">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Controls Grid -->
            <div class="controls-grid" id="controlsContainer">
                <!-- Generated via JS -->
            </div>
        </div>

        <!-- Keyboard -->
        <div class="keyboard-area">
            <div class="keys-container" id="kbd">
                <!-- White Keys -->
                <div class="key-white" data-note="C1">C</div>
                <div class="key-white" data-note="D1">D</div>
                <div class="key-white" data-note="E1">E</div>
                <div class="key-white" data-note="F1">F</div>
                <div class="key-white" data-note="G1">G</div>
                <div class="key-white" data-note="A1">A</div>
                <div class="key-white" data-note="B1">B</div>
                <div class="key-white" data-note="C2">C</div>
                <div class="key-white" data-note="D2">D</div>
                <div class="key-white" data-note="E2">E</div>
                <div class="key-white" data-note="F2">F</div>
                <div class="key-white" data-note="G2">G</div>
                <div class="key-white" data-note="A2">A</div>
                <div class="key-white" data-note="B2">B</div>

                <!-- Black Keys -->
                <div class="key-black bk-1" data-note="C#1"></div>
                <div class="key-black bk-2" data-note="D#1"></div>
                <div class="key-black bk-3" data-note="F#1"></div>
                <div class="key-black bk-4" data-note="G#1"></div>
                <div class="key-black bk-5" data-note="A#1"></div>
                <div class="key-black bk-6" data-note="C#2"></div>
                <div class="key-black bk-7" data-note="D#2"></div>
                <div class="key-black bk-8" data-note="F#2"></div>
                <div class="key-black bk-9" data-note="G#2"></div>
                <div class="key-black bk-10" data-note="A#2"></div>
            </div>
        </div>
    </div>

    <script>
        // --- Config ---
        const CONTROLS = [
            { id: 'sampleStart', name: 'Start', min: 0, max: 100, val: 0, step: 1, unit: '%', hl: true },
            { id: 'sampleEnd', name: 'End', min: 0, max: 100, val: 100, step: 1, unit: '%', hl: true },
            { id: 'grainSize', name: 'Size', min: 10, max: 500, val: 100, step: 1, unit: 'ms' },
            { id: 'density', name: 'Dens', min: 1, max: 50, val: 15, step: 1, unit: '' },
            { id: 'position', name: 'Scan', min: 0, max: 100, val: 0, step: 0.1, unit: '%', hl: true },
            { id: 'spray', name: 'Spray', min: 0, max: 100, val: 10, step: 1, unit: '' },
            { id: 'attack', name: 'Atk', min: 1, max: 200, val: 20, step: 1, unit: 'ms' },
            { id: 'release', name: 'Rel', min: 1, max: 500, val: 100, step: 1, unit: 'ms' },
            { id: 'pitchVar', name: 'P.Rnd', min: 0, max: 100, val: 0, step: 1, unit: '' },
            { id: 'panSpread', name: 'Width', min: 0, max: 100, val: 80, step: 1, unit: '%' },
            { id: 'reverb', name: 'Verb', min: 0, max: 100, val: 25, step: 1, unit: '%' },
            { id: 'volume', name: 'Vol', min: 0, max: 100, val: 85, step: 1, unit: '%' }
        ];

        const FREQS = {
            'C1':32.7,'C#1':34.6,'D1':36.7,'D#1':38.9,'E1':41.2,'F1':43.7,'F#1':46.2,'G1':49.0,'G#1':51.9,'A1':55.0,'A#1':58.3,'B1':61.7,
            'C2':65.4,'C#2':69.3,'D2':73.4,'D#2':77.8,'E2':82.4,'F2':87.3,'F#2':92.5,'G2':98.0,'G#2':103.8,'A2':110.0,'A#2':116.5,'B2':123.5
        };

        // --- State ---
        let actx = null;
        let buf = null;
        let mRec = null;
        let chunks = [];
        let isRec = false;
        
        let revNode, dryNode, wetNode, masterNode;
        
        // LFO
        let lfo = { ph: 0, last: 0, val: 0, bpm: 120, depth: 0.5, shape: 'sine' };
        
        // Params { id: { base, min, max, mod: bool, inv: bool } }
        let params = {};
        // Current Effective Values (cached)
        let effective = {};
        
        // Active Notes
        let voices = new Map();

        // --- Init ---
        function initUI() {
            const grid = document.getElementById('controlsContainer');
            CONTROLS.forEach(c => {
                // Setup State
                params[c.id] = { base: c.val, min: c.min, max: c.max, mod: false, inv: false };
                effective[c.id] = c.val;

                // Create DOM
                const div = document.createElement('div');
                div.className = `control-strip ${c.hl ? 'hl' : ''}`;
                div.innerHTML = `
                    <div class="strip-header">
                        <span class="strip-label">${c.name}</span>
                        <span class="strip-val" id="val_${c.id}">${c.val}${c.unit}</span>
                    </div>
                    <div class="strip-body">
                        <input type="range" id="sl_${c.id}" min="${c.min}" max="${c.max}" step="${c.step}" value="${c.val}">
                        <button class="tgl-btn" id="btn_m_${c.id}">M</button>
                        <button class="tgl-btn" id="btn_i_${c.id}">I</button>
                    </div>
                `;
                grid.appendChild(div);

                // Events
                const slider = div.querySelector('input');
                const mBtn = div.querySelector(`#btn_m_${c.id}`);
                const iBtn = div.querySelector(`#btn_i_${c.id}`);

                slider.addEventListener('input', e => {
                    params[c.id].base = parseFloat(e.target.value);
                    if (!params[c.id].mod) updateLabel(c.id, c.unit);
                    if(c.id === 'sampleStart' || c.id === 'sampleEnd') drawWave();
                });

                mBtn.addEventListener('click', () => {
                    params[c.id].mod = !params[c.id].mod;
                    mBtn.classList.toggle('active-mod', params[c.id].mod);
                });

                iBtn.addEventListener('click', () => {
                    params[c.id].inv = !params[c.id].inv;
                    iBtn.classList.toggle('active-inv', params[c.id].inv);
                });
            });

            // LFO Events
            document.getElementById('lfoRate').addEventListener('input', e => {
                lfo.bpm = parseFloat(e.target.value);
            });
            document.getElementById('lfoDepth').addEventListener('input', e => {
                lfo.depth = parseFloat(e.target.value) / 100;
            });
            document.getElementById('lfoShape').addEventListener('change', e => {
                lfo.shape = e.target.value;
            });
        }

        function updateLabel(id, unit) {
            const el = document.getElementById(`val_${id}`);
            if(el) {
                let v = effective[id];
                if(v % 1 !== 0) v = v.toFixed(1);
                else v = Math.round(v);
                el.innerText = v + unit;
            }
        }

        // --- Audio Core ---
        document.getElementById('start-btn').addEventListener('click', async () => {
            if(!actx) {
                const AC = window.AudioContext || window.webkitAudioContext;
                actx = new AC({ latencyHint: 'interactive' });
            }
            if(actx.state === 'suspended') await actx.resume();

            // Unlock iOS Audio with Silent Buffer
            const buffer = actx.createBuffer(1, 1, 22050);
            const source = actx.createBufferSource();
            source.buffer = buffer;
            source.connect(actx.destination);
            source.start(0);

            await buildFX();
            
            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('status').innerText = "Engine Active";
            
            lfo.last = actx.currentTime;
            requestAnimationFrame(loop);
        });

        async function buildFX() {
            masterNode = actx.createGain();
            masterNode.connect(actx.destination);
            
            revNode = actx.createConvolver();
            // Impulse
            const rate = actx.sampleRate;
            const len = rate * 2.0;
            const buf = actx.createBuffer(2, len, rate);
            for(let c=0;c<2;c++) {
                const d=buf.getChannelData(c);
                for(let i=0;i<len;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/len,3);
            }
            revNode.buffer = buf;

            dryNode = actx.createGain();
            wetNode = actx.createGain();

            dryNode.connect(masterNode);
            revNode.connect(wetNode);
            wetNode.connect(masterNode);
        }

        // --- Main Loop (LFO + UI) ---
        function loop() {
            if(!actx) return;
            const now = actx.currentTime;
            const dt = now - lfo.last;
            lfo.last = now;

            // 1. Calc LFO
            lfo.ph += dt * (lfo.bpm / 60) * 2 * Math.PI;
            const p = lfo.ph % (2 * Math.PI);
            let raw = 0;
            if(lfo.shape === 'sine') raw = Math.sin(p);
            else if(lfo.shape === 'square') raw = p < Math.PI ? 1 : -1;
            else if(lfo.shape === 'saw') raw = (p / (2*Math.PI))*2 - 1;
            else if(lfo.shape === 'tri') {
                const n = p / (2*Math.PI);
                raw = n < 0.5 ? 4*n - 1 : 3 - 4*n;
            }
            lfo.val = raw;

            // 2. Modulate Params
            for (const id in params) {
                const pConfig = params[id];
                let val = pConfig.base;
                
                if (pConfig.mod) {
                    const range = pConfig.max - pConfig.min;
                    // Inversion Logic: Multiply raw LFO by -1 if inverted
                    let lfoFactor = raw;
                    if (pConfig.inv) lfoFactor *= -1;

                    // Apply Depth scaling
                    const modAmt = lfoFactor * lfo.depth * (range * 0.5);
                    val += modAmt;
                    
                    // Clamp
                    val = Math.max(pConfig.min, Math.min(pConfig.max, val));
                }
                effective[id] = val;
                
                // Update UI Labels periodically or always? Always is smoothest.
                // Find unit
                const ctrl = CONTROLS.find(c=>c.id===id);
                if(pConfig.mod) {
                     updateLabel(id, ctrl ? ctrl.unit : '');
                     document.getElementById(`val_${id}`).style.color = 'var(--lfo-color)';
                } else {
                     document.getElementById(`val_${id}`).style.color = 'var(--accent)';
                }
            }

            // 3. Update Global FX
            if(dryNode && wetNode) {
                const r = effective.reverb / 100;
                const v = effective.volume / 100;
                wetNode.gain.value = r;
                dryNode.gain.value = 1.0 - (r * 0.4);
                masterNode.gain.value = v;
            }
            
            // 4. Redraw Wave if Markers Move
            if(params['sampleStart'].mod || params['sampleEnd'].mod) drawWave();

            requestAnimationFrame(loop);
        }

        // --- Recording ---
        document.getElementById('recordBtn').addEventListener('click', toggleRec);
        document.getElementById('clearBtn').addEventListener('click', () => {
            buf = null; 
            drawWave(); 
            document.getElementById('status').innerText = "Cleared";
        });

        async function toggleRec() {
            if(!actx) return;
            if(isRec) {
                mRec.stop();
                isRec = false;
                document.getElementById('recordBtn').classList.remove('recording');
                document.getElementById('recordBtn').innerText = "REC MIC";
            } else {
                if(actx.state === 'suspended') await actx.resume();
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { echoCancellation: false, autoGainControl: false, noiseSuppression: false } 
                    });
                    
                    // iOS Polyfill/Check
                    let opts = {};
                    if (MediaRecorder.isTypeSupported('audio/webm')) opts = { mimeType: 'audio/webm' };
                    else if (MediaRecorder.isTypeSupported('audio/mp4')) opts = { mimeType: 'audio/mp4' };
                    
                    mRec = new MediaRecorder(stream, opts);
                    chunks = [];
                    mRec.ondataavailable = e => chunks.push(e.data);
                    mRec.onstop = async () => {
                        const blob = new Blob(chunks, { type: mRec.mimeType });
                        const arr = await blob.arrayBuffer();
                        actx.decodeAudioData(arr, b => {
                            buf = b;
                            drawWave();
                            document.getElementById('status').innerText = `Buffer: ${b.duration.toFixed(2)}s`;
                        });
                        stream.getTracks().forEach(t=>t.stop());
                    };
                    mRec.start();
                    isRec = true;
                    document.getElementById('recordBtn').classList.add('recording');
                    document.getElementById('recordBtn').innerText = "STOP";
                    document.getElementById('status').innerText = "Recording...";
                } catch(e) {
                    alert("Mic Access Denied/Error: " + e.message);
                }
            }
        }

        // --- Waveform ---
        function drawWave() {
            const cvs = document.getElementById('waveCanvas');
            const ctx = cvs.getContext('2d');
            const w = cvs.width = cvs.clientWidth;
            const h = cvs.height = cvs.clientHeight;

            ctx.fillStyle = '#111'; ctx.fillRect(0,0,w,h);
            if(!buf) return;

            const data = buf.getChannelData(0);
            const step = Math.ceil(data.length/w);
            const amp = h/2;

            ctx.beginPath(); ctx.strokeStyle = '#0ff';
            for(let i=0;i<w;i++) {
                let max = -1, min = 1;
                for(let j=0; j<step; j++) {
                    const val = data[i*step+j];
                    if(val>max) max=val;
                    if(val<min) min=val;
                }
                ctx.moveTo(i, (1+min)*amp);
                ctx.lineTo(i, (1+max)*amp);
            }
            ctx.stroke();

            // Markers (Modulated)
            const s = effective.sampleStart / 100;
            const e = effective.sampleEnd / 100;
            
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(0,0,w*s,h);
            ctx.fillRect(w*e,0,w*(1-e),h);
            
            ctx.fillStyle = '#f00';
            ctx.fillRect(w*s, 0, 2, h);
            ctx.fillRect(w*e, 0, 2, h);
        }

        // --- Granular Engine ---
        function playGrain(note) {
            if(!buf) return;
            
            // Get Params
            let s = effective.sampleStart/100;
            let e = effective.sampleEnd/100;
            if(s>e) [s,e]=[e,s];
            
            const dur = buf.duration;
            const startT = dur * s;
            const endT = dur * e;
            const win = endT - startT;
            if(win <= 0) return;

            const pos = effective.position/100;
            const size = effective.grainSize/1000;
            const atk = effective.attack/1000;
            const rel = effective.release/1000;
            const spr = effective.spray/100;
            const pVar = effective.pitchVar/100;
            const wide = effective.panSpread/100;

            // Calc Position
            let offset = startT + (pos * win);
            offset += (Math.random()*2-1)*spr * win * 0.5;
            offset = Math.max(startT, Math.min(endT-size, offset));

            // Calc Rate
            const baseF = FREQS[note] || 65.4;
            let rate = baseF / 65.4; // Base C2
            rate *= (1 + (Math.random()*2-1)*pVar*0.1);

            // Graph
            const src = actx.createBufferSource();
            src.buffer = buf;
            src.playbackRate.value = rate;

            const env = actx.createGain();
            const pan = actx.createStereoPanner();

            pan.pan.value = (Math.random()*2-1)*wide;

            src.connect(env).connect(pan);
            pan.connect(dryNode);
            pan.connect(revNode);

            const t = actx.currentTime;
            env.gain.setValueAtTime(0, t);
            env.gain.linearRampToValueAtTime(1, t+atk);
            env.gain.linearRampToValueAtTime(0, t+size);

            src.start(t, offset, size);
            src.stop(t+size+0.1);
        }

        // --- Scheduling ---
        function startVoice(note) {
            if(!buf || voices.has(note)) return;

            function tick() {
                if(!voices.has(note)) return;
                playGrain(note);
                
                // Dynamic Density
                let d = effective.density;
                if(d < 1) d = 1; 
                const wait = 1000/d;
                voices.set(note, setTimeout(tick, wait));
            }
            tick();
        }

        function stopVoice(note) {
            if(voices.has(note)) {
                clearTimeout(voices.get(note));
                voices.delete(note);
            }
        }

        // --- Keyboard Inputs ---
        const keys = document.getElementById('kbd');
        
        // Use pointer events for multi-touch
        keys.querySelectorAll('div').forEach(k => {
            k.addEventListener('pointerdown', e => {
                e.preventDefault();
                k.classList.add('active');
                k.setPointerCapture(e.pointerId);
                startVoice(k.dataset.note);
            });
            k.addEventListener('pointerup', e => {
                k.classList.remove('active');
                k.releasePointerCapture(e.pointerId);
                stopVoice(k.dataset.note);
            });
            k.addEventListener('pointercancel', e => {
                k.classList.remove('active');
                stopVoice(k.dataset.note);
            });
             k.addEventListener('pointerleave', e => {
                // If you slide off key
                if(k.classList.contains('active')) {
                     k.classList.remove('active');
                     stopVoice(k.dataset.note);
                }
            });
        });

        // Run Init
        initUI();

    </script>
</body>
</html>
