<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Granular LFO</title>
    <style>
        :root {
            --bg-color: #151520;
            --panel-bg: rgba(30, 30, 40, 0.95);
            --accent: #00d4ff;
            --mod-active: #ffcc00;
            --inv-active: #ff4400;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #111;
            color: #ccc;
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* Prevent scrolling */
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* --- Overlays --- */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.3s;
        }
        #orientation-overlay { display: none; text-align: center; }
        
        @media screen and (orientation: portrait) {
            #orientation-overlay { display: flex; }
            .main-grid { display: none !important; }
        }

        button.start-btn {
            background: var(--accent); color: #000; border: none; padding: 15px 40px;
            font-size: 18px; border-radius: 30px; margin-top: 20px; font-weight: bold;
        }

        /* --- Main Layout --- */
        .main-grid {
            display: grid;
            grid-template-columns: 160px 1fr; /* Left panel fixed, right flexible */
            grid-template-rows: 1fr 100px;    /* Top section flex, Keyboard fixed height */
            gap: 4px;
            height: 100%;
            padding: 4px;
        }

        /* --- Panels --- */
        .panel {
            background: var(--panel-bg);
            border: 1px solid #333;
            border-radius: 6px;
            padding: 6px;
            display: flex;
            flex-direction: column;
        }

        /* --- Left: Rec & LFO --- */
        .left-col {
            grid-column: 1; grid-row: 1;
            gap: 4px;
        }

        .sub-panel {
            background: rgba(0,0,0,0.2);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 5px;
            display: flex; flex-direction: column; gap: 5px;
        }

        .panel-title { font-size: 10px; color: #888; text-transform: uppercase; font-weight: bold; letter-spacing: 1px; }

        /* Recording */
        .btn-row { display: flex; gap: 4px; }
        .btn {
            flex: 1; background: #333; color: #eee; border: none; padding: 8px 0;
            border-radius: 3px; font-size: 10px; font-weight: bold;
        }
        .btn.rec { background: #900; color: #fff; }
        .btn.rec.active { background: #f00; animation: pulse 1s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }

        #waveCanvas { width: 100%; height: 60px; background: #000; border: 1px solid #444; border-radius: 3px; }

        /* LFO Master */
        .lfo-ctrl { display: flex; justify-content: space-between; align-items: center; margin-top: 2px; }
        .lfo-label { font-size: 10px; color: var(--mod-active); }
        .lfo-val { font-size: 10px; color: #fff; }
        select { background: #222; color: #fff; border: 1px solid #444; font-size: 10px; width: 100%; }

        /* --- Center: Controls --- */
        .controls-col {
            grid-column: 2; grid-row: 1;
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4 columns */
            grid-auto-rows: minmax(min-content, 1fr);
            gap: 4px;
            overflow-y: auto; /* Scroll only if absolutely needed */
        }

        .slider-group {
            background: rgba(255,255,255,0.03);
            border: 1px solid transparent;
            border-radius: 4px;
            padding: 4px;
            display: flex; flex-direction: column; justify-content: center;
        }
        .slider-group.modulating { border-color: var(--mod-active); background: rgba(255,204,0,0.05); }

        .slider-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px; }
        .slider-name { font-size: 10px; color: #aaa; font-weight: bold; }
        
        .mod-tools { display: flex; gap: 2px; }
        .mini-btn {
            width: 16px; height: 16px; border: 1px solid #444; background: #222;
            color: #666; font-size: 8px; line-height: 14px; text-align: center;
            border-radius: 2px; padding: 0;
        }
        .mini-btn.m-btn.active { background: var(--mod-active); color: #000; border-color: var(--mod-active); }
        .mini-btn.i-btn.active { background: var(--inv-active); color: #fff; border-color: var(--inv-active); }

        .param-val { font-size: 10px; color: var(--accent); min-width: 25px; text-align: right; }

        input[type=range] {
            width: 100%; height: 20px; /* larger touch target */
            background: transparent; -webkit-appearance: none; margin: 0;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px;
            border-radius: 50%; background: var(--accent); margin-top: -6px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            height: 2px; background: #444; width: 100%;
        }

        /* --- Bottom: Keyboard --- */
        .keyboard-col {
            grid-column: 1 / -1; grid-row: 2;
            display: flex; gap: 1px; padding: 2px;
            background: #222; border-top: 2px solid var(--accent);
        }
        .key-wrapper {
            position: relative; flex: 1; display: flex;
            background: #000; /* gap color */
        }
        .key {
            flex: 1; border-radius: 0 0 3px 3px;
            cursor: pointer;
            display: flex; align-items: flex-end; justify-content: center;
            padding-bottom: 5px; font-size: 10px; font-weight: bold; color: #333;
            background: #fff;
        }
        .key.black {
            position: absolute; top: 0; left: -30%; width: 60%; height: 60%;
            background: #000; color: #fff; z-index: 10;
            border: 1px solid #444; border-top: none;
        }
        .key.active { background: var(--accent); }
        .key.black.active { background: var(--accent); }

    </style>
</head>
<body>

    <!-- Rotation Warning -->
    <div id="orientation-overlay" class="overlay">
        <h2 style="color:var(--accent)">Rotate Device</h2>
    </div>

    <!-- Start Screen -->
    <div id="start-overlay" class="overlay">
        <h1 style="color:var(--accent)">Granular LFO</h1>
        <button class="start-btn" id="startBtn">START ENGINE</button>
    </div>

    <!-- Main Interface -->
    <div class="main-grid">
        
        <!-- Left Column -->
        <div class="panel left-col">
            <!-- Recorder -->
            <div class="sub-panel">
                <div class="panel-title">Sampler</div>
                <div class="btn-row">
                    <button id="recBtn" class="btn rec">MIC</button>
                    <button id="clearBtn" class="btn">CLR</button>
                </div>
                <canvas id="waveCanvas"></canvas>
                <div id="status" style="font-size:9px; color:#666; text-align:center;">Ready</div>
            </div>

            <!-- LFO Master -->
            <div class="sub-panel" style="border-color: var(--mod-active);">
                <div class="panel-title" style="color:var(--mod-active)">LFO Master</div>
                <select id="lfoShape">
                    <option value="sine">Sine</option>
                    <option value="saw">Sawtooth</option>
                    <option value="square">Square</option>
                    <option value="tri">Triangle</option>
                </select>

                <div class="lfo-ctrl">
                    <span class="lfo-label">Rate</span>
                    <span class="lfo-val" id="disp_lfoRate">2.0Hz</span>
                </div>
                <input type="range" id="lfoRate" min="0.1" max="20" step="0.1" value="2.0">

                <div class="lfo-ctrl">
                    <span class="lfo-label">Depth</span>
                    <span class="lfo-val" id="disp_lfoDepth">50%</span>
                </div>
                <input type="range" id="lfoDepth" min="0" max="100" step="1" value="50">
            </div>
        </div>

        <!-- Right Column (Controls) -->
        <div class="panel controls-col">
            <!-- Params generated by JS for consistency -->
            <!-- Start -->
            <div class="slider-group" id="grp_start">
                <div class="slider-header">
                    <span class="slider-name">Start</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="start">M</button>
                        <button class="mini-btn i-btn" data-id="start">I</button>
                    </div>
                    <span class="param-val" id="val_start">0%</span>
                </div>
                <input type="range" id="p_start" min="0" max="100" value="0">
            </div>

            <!-- End -->
            <div class="slider-group" id="grp_end">
                <div class="slider-header">
                    <span class="slider-name">End</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="end">M</button>
                        <button class="mini-btn i-btn" data-id="end">I</button>
                    </div>
                    <span class="param-val" id="val_end">100%</span>
                </div>
                <input type="range" id="p_end" min="0" max="100" value="100">
            </div>

            <!-- Grain Size -->
            <div class="slider-group" id="grp_size">
                <div class="slider-header">
                    <span class="slider-name">Size</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="size">M</button>
                        <button class="mini-btn i-btn" data-id="size">I</button>
                    </div>
                    <span class="param-val" id="val_size">100ms</span>
                </div>
                <input type="range" id="p_size" min="10" max="500" value="100">
            </div>

            <!-- Density -->
            <div class="slider-group" id="grp_dens">
                <div class="slider-header">
                    <span class="slider-name">Dens</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="dens">M</button>
                        <button class="mini-btn i-btn" data-id="dens">I</button>
                    </div>
                    <span class="param-val" id="val_dens">10</span>
                </div>
                <input type="range" id="p_dens" min="1" max="50" value="10">
            </div>

            <!-- Position -->
            <div class="slider-group" id="grp_pos">
                <div class="slider-header">
                    <span class="slider-name">Pos</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="pos">M</button>
                        <button class="mini-btn i-btn" data-id="pos">I</button>
                    </div>
                    <span class="param-val" id="val_pos">0%</span>
                </div>
                <input type="range" id="p_pos" min="0" max="100" value="0">
            </div>

            <!-- Spray -->
            <div class="slider-group" id="grp_spray">
                <div class="slider-header">
                    <span class="slider-name">Spray</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="spray">M</button>
                        <button class="mini-btn i-btn" data-id="spray">I</button>
                    </div>
                    <span class="param-val" id="val_spray">0%</span>
                </div>
                <input type="range" id="p_spray" min="0" max="100" value="0">
            </div>

            <!-- Attack -->
            <div class="slider-group" id="grp_atk">
                <div class="slider-header">
                    <span class="slider-name">Atk</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="atk">M</button>
                        <button class="mini-btn i-btn" data-id="atk">I</button>
                    </div>
                    <span class="param-val" id="val_atk">10ms</span>
                </div>
                <input type="range" id="p_atk" min="5" max="500" value="10">
            </div>

            <!-- Release -->
            <div class="slider-group" id="grp_rel">
                <div class="slider-header">
                    <span class="slider-name">Rel</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="rel">M</button>
                        <button class="mini-btn i-btn" data-id="rel">I</button>
                    </div>
                    <span class="param-val" id="val_rel">100ms</span>
                </div>
                <input type="range" id="p_rel" min="5" max="1000" value="100">
            </div>

            <!-- Pitch Rand -->
            <div class="slider-group" id="grp_tune">
                <div class="slider-header">
                    <span class="slider-name">TuneRnd</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="tune">M</button>
                        <button class="mini-btn i-btn" data-id="tune">I</button>
                    </div>
                    <span class="param-val" id="val_tune">0%</span>
                </div>
                <input type="range" id="p_tune" min="0" max="100" value="0">
            </div>

            <!-- Pan -->
            <div class="slider-group" id="grp_pan">
                <div class="slider-header">
                    <span class="slider-name">Pan</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="pan">M</button>
                        <button class="mini-btn i-btn" data-id="pan">I</button>
                    </div>
                    <span class="param-val" id="val_pan">50%</span>
                </div>
                <input type="range" id="p_pan" min="0" max="100" value="50">
            </div>

            <!-- Reverb -->
            <div class="slider-group" id="grp_verb">
                <div class="slider-header">
                    <span class="slider-name">Verb</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="verb">M</button>
                        <button class="mini-btn i-btn" data-id="verb">I</button>
                    </div>
                    <span class="param-val" id="val_verb">20%</span>
                </div>
                <input type="range" id="p_verb" min="0" max="100" value="20">
            </div>

            <!-- Vol -->
            <div class="slider-group" id="grp_vol">
                <div class="slider-header">
                    <span class="slider-name">Vol</span>
                    <div class="mod-tools">
                        <button class="mini-btn m-btn" data-id="vol">M</button>
                        <button class="mini-btn i-btn" data-id="vol">I</button>
                    </div>
                    <span class="param-val" id="val_vol">80%</span>
                </div>
                <input type="range" id="p_vol" min="0" max="100" value="80">
            </div>
        </div>

        <!-- Keyboard (C1 to B2) -->
        <div class="panel keyboard-col" id="kbContainer">
            <!-- Generated via JS for precision -->
        </div>

    </div>

    <script>
        // --- Engine Globals ---
        let actx;
        let buffer = null;
        let isRec = false;
        let recorder = null;
        let chunks = [];
        let grains = new Map(); // key: note, val: timeoutId

        // Effects
        let masterNode, dryNode, wetNode, verbNode;

        // LFO
        let lfo = {
            phase: 0,
            val: 0,
            lastT: 0
        };

        // Params Configuration
        // All "p_" ids
        const params = {
            'start': { val: 0, min:0, max:100, mod:false, inv:false, disp:'%' },
            'end':   { val: 100, min:0, max:100, mod:false, inv:false, disp:'%' },
            'size':  { val: 100, min:10, max:500, mod:false, inv:false, disp:'ms' },
            'dens':  { val: 10, min:1, max:50, mod:false, inv:false, disp:'' },
            'pos':   { val: 0, min:0, max:100, mod:false, inv:false, disp:'%' },
            'spray': { val: 0, min:0, max:100, mod:false, inv:false, disp:'%' },
            'atk':   { val: 10, min:5, max:500, mod:false, inv:false, disp:'ms' },
            'rel':   { val: 100, min:5, max:1000, mod:false, inv:false, disp:'ms' },
            'tune':  { val: 0, min:0, max:100, mod:false, inv:false, disp:'%' },
            'pan':   { val: 50, min:0, max:100, mod:false, inv:false, disp:'%' },
            'verb':  { val: 20, min:0, max:100, mod:false, inv:false, disp:'%' },
            'vol':   { val: 80, min:0, max:100, mod:false, inv:false, disp:'%' },
        };

        // Note Frequencies (C1 - B2)
        const freqs = {
            'C1': 32.70, 'C#1': 34.65, 'D1': 36.71, 'D#1': 38.89, 'E1': 41.20, 'F1': 43.65, 'F#1': 46.25, 'G1': 49.00, 'G#1': 51.91, 'A1': 55.00, 'A#1': 58.27, 'B1': 61.74,
            'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 98.00, 'G#2': 103.83, 'A2': 110.00, 'A#2': 116.54, 'B2': 123.47
        };
        const rootC2 = 65.41;

        // --- Init ---
        document.getElementById('startBtn').addEventListener('click', async () => {
            // iOS Unlock
            const AC = window.AudioContext || window.webkitAudioContext;
            actx = new AC();
            
            // Play Silent Buffer
            const sBuf = actx.createBuffer(1, 1, 22050);
            const src = actx.createBufferSource();
            src.buffer = sBuf;
            src.connect(actx.destination);
            src.start(0);

            if(actx.state === 'suspended') await actx.resume();

            initFX();
            genKeyboard();
            
            // Start Loop
            lfo.lastT = performance.now();
            requestAnimationFrame(loop);

            document.getElementById('start-overlay').style.display = 'none';
        });

        function initFX() {
            masterNode = actx.createGain();
            masterNode.connect(actx.destination);
            
            dryNode = actx.createGain();
            wetNode = actx.createGain();
            verbNode = actx.createConvolver();

            // Simple Reverb Impulse
            const len = actx.sampleRate * 2;
            const imp = actx.createBuffer(2, len, actx.sampleRate);
            for(let c=0; c<2; c++){
                const d = imp.getChannelData(c);
                for(let i=0; i<len; i++) d[i] = (Math.random()*2-1) * Math.pow(1-i/len, 3);
            }
            verbNode.buffer = imp;

            dryNode.connect(masterNode);
            verbNode.connect(wetNode);
            wetNode.connect(masterNode);
        }

        function genKeyboard() {
            const kb = document.getElementById('kbContainer');
            const notes = ['C','D','E','F','G','A','B'];
            const blacks = [1,1,0,1,1,1,0]; // relative to white keys: C#, D#, -, F#, G#, A#, -
            
            // Generate 2 octaves
            let octaves = [1, 2];
            octaves.forEach(oct => {
                notes.forEach((n, i) => {
                    // Wrapper for white key
                    const wrap = document.createElement('div');
                    wrap.className = 'key-wrapper';
                    
                    const white = document.createElement('div');
                    white.className = 'key white';
                    white.dataset.note = n + oct;
                    white.innerText = n + oct;
                    addKeyListeners(white);
                    wrap.appendChild(white);

                    // Add black key if needed
                    if (blacks[i]) {
                        const black = document.createElement('div');
                        black.className = 'key black';
                        let bn = n + '#' + oct;
                        black.dataset.note = bn;
                        addKeyListeners(black);
                        wrap.appendChild(black);
                    }
                    kb.appendChild(wrap);
                });
            });
        }

        function addKeyListeners(el) {
            el.addEventListener('pointerdown', e => {
                e.preventDefault();
                el.classList.add('active');
                el.setPointerCapture(e.pointerId);
                noteOn(el.dataset.note);
            });
            el.addEventListener('pointerup', e => {
                el.classList.remove('active');
                el.releasePointerCapture(e.pointerId);
                noteOff(el.dataset.note);
            });
            el.addEventListener('pointerleave', e => {
                 if(el.classList.contains('active')) {
                     el.classList.remove('active');
                     noteOff(el.dataset.note);
                 }
            });
        }

        // --- Core Loop (LFO + UI) ---
        function loop(now) {
            if(!actx) return;

            // 1. Calc LFO
            const dt = (now - lfo.lastT) / 1000;
            lfo.lastT = now;
            
            const rate = parseFloat(document.getElementById('lfoRate').value);
            const depth = parseFloat(document.getElementById('lfoDepth').value) / 100;
            const shape = document.getElementById('lfoShape').value;

            // Update Labels
            document.getElementById('disp_lfoRate').innerText = rate.toFixed(1) + 'Hz';
            document.getElementById('disp_lfoDepth').innerText = Math.round(depth*100) + '%';

            lfo.phase += rate * dt;
            if(lfo.phase > 1) lfo.phase -= 1;

            let raw = 0;
            if(shape === 'sine') raw = Math.sin(lfo.phase * Math.PI * 2);
            else if(shape === 'saw') raw = 2 * (lfo.phase - 0.5);
            else if(shape === 'square') raw = lfo.phase < 0.5 ? 1 : -1;
            else if(shape === 'tri') raw = Math.abs(2 * (lfo.phase - 0.5)) * 2 - 1;

            lfo.val = raw;

            // 2. Update Modulated Params
            for(let k in params) {
                const p = params[k];
                // Base value from slider
                const slider = document.getElementById('p_' + k);
                let current = parseFloat(slider.value);
                p.val = current; // update base

                if(p.mod) {
                    const range = p.max - p.min;
                    // Bipolar modulation around current value
                    // e.g. slider at 50, depth 100% -> swings full range relative to 50?
                    // Usually: Val + (LFO * Depth * Range/2)
                    let modAmt = lfo.val * depth * (range/2);
                    if(p.inv) modAmt *= -1;
                    
                    current += modAmt;
                    // Clamp
                    current = Math.max(p.min, Math.min(p.max, current));
                    
                    // Visual feedback
                    const span = document.getElementById('val_' + k);
                    let txt = (k==='pos' || k==='size') ? current.toFixed(0) : Math.round(current);
                    span.innerText = txt + p.disp;
                    span.style.color = 'var(--mod-active)';
                } else {
                     const span = document.getElementById('val_' + k);
                     span.style.color = 'var(--accent)';
                     // Ensure label matches slider if not modulating
                     let txt = (k==='pos' || k==='size') ? current.toFixed(0) : Math.round(current);
                     span.innerText = txt + p.disp;
                }
            }

            // 3. Update Audio Nodes (Vol/Verb)
            if(masterNode) {
                const vol = getEff('vol') / 100;
                const verb = getEff('verb') / 100;
                
                masterNode.gain.value = vol;
                dryNode.gain.value = 1.0 - (verb * 0.5);
                wetNode.gain.value = verb;
            }

            // 4. Animate Waveform markers
            drawMarkers();

            requestAnimationFrame(loop);
        }

        // Helper to get effective value
        function getEff(key) {
            const p = params[key];
            const slider = parseFloat(document.getElementById('p_'+key).value);
            if(!p.mod) return slider;
            
            const depth = parseFloat(document.getElementById('lfoDepth').value) / 100;
            const range = p.max - p.min;
            let mod = lfo.val * depth * (range/2);
            if(p.inv) mod *= -1;
            return Math.max(p.min, Math.min(p.max, slider + mod));
        }

        // --- Grain Logic ---
        function noteOn(note) {
            if(!buffer) return;
            if(grains.has(note)) return;

            function play() {
                spawnGrain(note);
                // Dynamic density
                const dens = Math.max(1, getEff('dens'));
                const wait = 1000 / dens;
                const id = setTimeout(play, wait);
                grains.set(note, id);
            }
            play();
        }

        function noteOff(note) {
            if(grains.has(note)) {
                clearTimeout(grains.get(note));
                grains.delete(note);
            }
        }

        function spawnGrain(note) {
            // Get Params
            const size = getEff('size')/1000;
            const atk = getEff('atk')/1000;
            const rel = getEff('rel')/1000;
            const spray = getEff('spray')/100;
            const tune = getEff('tune')/100;
            const panV = getEff('pan')/100; // 0..1

            // Pos
            const s = getEff('start')/100;
            const e = getEff('end')/100;
            const start = Math.min(s,e) * buffer.duration;
            const end = Math.max(s,e) * buffer.duration;
            const win = end - start;
            
            const posPct = getEff('pos')/100;
            let pos = start + (posPct * win);
            
            // Apply Spray
            pos += (Math.random()*2-1) * spray * win * 0.5;
            pos = Math.max(start, Math.min(end - size, pos));

            // Pitch
            const freq = freqs[note];
            let rate = freq / rootC2;
            // Apply Tune Random
            rate *= (1 + (Math.random()*2-1) * tune * 0.1);

            // Audio Graph
            const src = actx.createBufferSource();
            src.buffer = buffer;
            src.playbackRate.value = rate;

            const env = actx.createGain();
            const panner = actx.createStereoPanner();
            
            // Random Pan Spread centered on Pan knob
            // Pan knob 0 = Left, 50 = Center, 100 = Right
            // If Pan is 50%, spread is full -1 to 1? Or Spread is separate?
            // The prompt didn't ask for separate spread. Let's make "Stereo" knob control random width.
            // Oh, previously it was "Stereo/PanSpread". 
            // Let's treat the slider as "Spread" amount (0=mono, 100=wide) centered.
            
            // Recalculating based on prompt "Stereo" -> spread.
            const spread = panV; 
            panner.pan.value = (Math.random()*2-1) * spread;

            src.connect(env).connect(panner);
            panner.connect(dryNode);
            panner.connect(verbNode); // Send to reverb aux

            // Envelope
            const now = actx.currentTime;
            env.gain.setValueAtTime(0, now);
            env.gain.linearRampToValueAtTime(1, now + atk);
            env.gain.linearRampToValueAtTime(0, now + size); // size acts as hold+decay approx? simpler: total duration
            
            src.start(now, pos);
            src.stop(now + size + 0.1);
        }

        // --- Rec ---
        const recBtn = document.getElementById('recBtn');
        const clearBtn = document.getElementById('clearBtn');
        const cvs = document.getElementById('waveCanvas');
        const ctx = cvs.getContext('2d');

        recBtn.addEventListener('click', async () => {
            if(!actx) return;
            if(isRec) stopRec(); else startRec();
        });

        clearBtn.addEventListener('click', () => {
            buffer = null;
            ctx.clearRect(0,0,cvs.width,cvs.height);
            document.getElementById('status').innerText = "Cleared";
        });

        async function startRec() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({audio:true});
                // iOS Mime check
                let opts = {};
                if(MediaRecorder.isTypeSupported('audio/mp4')) opts={mimeType:'audio/mp4'};
                else if(MediaRecorder.isTypeSupported('audio/webm')) opts={mimeType:'audio/webm'};
                
                try { recorder = new MediaRecorder(stream, opts); }
                catch(e) { recorder = new MediaRecorder(stream); } // fallback

                chunks = [];
                recorder.ondataavailable = e => { if(e.data.size>0) chunks.push(e.data); };
                recorder.onstop = async () => {
                    const blob = new Blob(chunks, { type: recorder.mimeType });
                    const arr = await blob.arrayBuffer();
                    actx.decodeAudioData(arr, b => {
                        buffer = b;
                        drawWave();
                        document.getElementById('status').innerText = b.duration.toFixed(2)+"s";
                    }, e => alert('Decode error: '+e));
                    stream.getTracks().forEach(t=>t.stop());
                };

                recorder.start();
                isRec = true;
                recBtn.classList.add('active');
                recBtn.innerText = "STOP";
            } catch(e) {
                alert("Mic Error: " + e.message);
            }
        }

        function stopRec() {
            if(recorder && isRec) {
                recorder.stop();
                isRec = false;
                recBtn.classList.remove('active');
                recBtn.innerText = "MIC";
            }
        }

        // --- Drawing ---
        function drawWave() {
            if(!buffer) return;
            // scale canvas
            cvs.width = cvs.offsetWidth;
            cvs.height = cvs.offsetHeight;
            const w = cvs.width;
            const h = cvs.height;
            const d = buffer.getChannelData(0);
            const step = Math.ceil(d.length/w);
            const amp = h/2;

            ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
            ctx.beginPath(); ctx.strokeStyle = '#0ff';
            for(let i=0; i<w; i++){
                let min=1, max=-1;
                for(let j=0; j<step; j++){
                    const v = d[i*step+j];
                    if(v<min)min=v; if(v>max)max=v;
                }
                ctx.moveTo(i, (1+min)*amp);
                ctx.lineTo(i, (1+max)*amp);
            }
            ctx.stroke();
            drawMarkers();
        }

        function drawMarkers() {
            // Re-draw overlay on canvas without erasing wave is hard without layers.
            // Simplified: Just re-draw wave then markers.
            if(!buffer) return;
            const w = cvs.width;
            const h = cvs.height;
            
            // Clear entire canvas to avoid trails? No, better to redraw wave + markers every frame if modulating?
            // Yes.
            
            const d = buffer.getChannelData(0);
            const step = Math.ceil(d.length/w);
            const amp = h/2;

            ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
            ctx.beginPath(); ctx.strokeStyle = '#0ff';
            
            // Optimized draw: only draw every 2nd pixel to save perf on modulation?
            // keeping standard for now
            for(let i=0; i<w; i+=2){ 
                const v = d[i*step];
                ctx.moveTo(i, (1+v)*amp);
                ctx.lineTo(i, (1+v)*amp+1); // dots
            }
            ctx.stroke();

            // Markers
            const s = getEff('start')/100;
            const e = getEff('end')/100;
            
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(0,0,w*s,h);
            ctx.fillRect(w*e,0,w*(1-e),h);
            
            ctx.strokeStyle = '#f04';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(w*s,0); ctx.lineTo(w*s,h); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(w*e,0); ctx.lineTo(w*e,h); ctx.stroke();
            ctx.lineWidth = 1;
        }

        // --- Mod Buttons Logic ---
        document.querySelectorAll('.m-btn').forEach(b => {
            b.addEventListener('click', e => {
                const id = e.target.dataset.id;
                params[id].mod = !params[id].mod;
                e.target.classList.toggle('active', params[id].mod);
                document.getElementById('grp_'+id).classList.toggle('modulating', params[id].mod);
            });
        });
        document.querySelectorAll('.i-btn').forEach(b => {
            b.addEventListener('click', e => {
                const id = e.target.dataset.id;
                params[id].inv = !params[id].inv;
                e.target.classList.toggle('active', params[id].inv);
            });
        });

        // --- Input Events ---
        document.querySelectorAll('input[type=range]').forEach(i => {
            i.addEventListener('input', e => {
                if(e.target.id === 'lfoRate' || e.target.id === 'lfoDepth') return;
                // Params handle themselves in the loop
            });
        });

        window.addEventListener('resize', () => { if(buffer) drawWave(); });
    </script>
</body>
</html>
