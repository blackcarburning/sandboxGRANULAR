<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="screen-orientation" content="landscape">
    <meta name="x5-orientation" content="landscape">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Granular Synthesizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @media screen and (orientation: portrait) {
            html {
                transform: rotate(90deg);
                transform-origin: left top;
                width: 100vh;
                height: 100vw;
                overflow-x: hidden;
                position: absolute;
                top: 100%;
                left: 0;
            }
        }

        html, body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: none;
            -webkit-touch-callout: none;
        }

        .synth-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            padding: 10px;
            padding-bottom: 0;
        }

        .top-section {
            display: flex;
            gap: 10px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .recording-section {
            flex: 0 0 200px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 10px;
            padding: 10px;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .recording-section h2 {
            color: #00d4ff;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .recording-buttons {
            display: flex;
            gap: 5px;
        }

        button {
            padding: 8px 12px;
            font-size: 11px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            user-select: none;
            -webkit-user-drag: none;
            touch-action: manipulation;
        }

        #recordBtn {
            background: linear-gradient(135deg, #ff0844 0%, #ff6b6b 100%);
            color: white;
            flex: 1;
        }

        #recordBtn.recording {
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        #clearBtn {
            background: linear-gradient(135deg, #666 0%, #888 100%);
            color: white;
        }

        #waveformCanvas {
            width: 100%;
            flex: 1;
            min-height: 60px;
            background: #0a0a15;
            border-radius: 6px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .status {
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            text-align: center;
            color: #00d4ff;
            font-size: 10px;
        }

        .controls-section {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 10px;
            padding: 10px;
            border: 1px solid rgba(0, 212, 255, 0.2);
            overflow: hidden;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #b0b0b0;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .control-group .value {
            color: #00d4ff;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(0, 212, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
            touch-action: manipulation;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
        }

        .keyboard-section {
            flex: 0 0 120px;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding: 5px 0;
            background: rgba(20, 20, 40, 0.9);
            border-top: 2px solid rgba(0, 212, 255, 0.3);
        }

        .keyboard {
            display: flex;
            position: relative;
            height: 110px;
        }

        .key {
            position: relative;
            cursor: pointer;
            border-radius: 0 0 6px 6px;
            transition: all 0.05s ease;
            user-select: none;
            -webkit-user-select: none;
            -webkit-user-drag: none;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 5px;
            font-size: 9px;
            font-weight: bold;
            touch-action: none;
        }

        .key.white {
            width: 36px;
            height: 110px;
            background: linear-gradient(to bottom, #ffffff 0%, #e8e8e8 100%);
            border: 1px solid #999;
            color: #333;
            z-index: 1;
            margin: 0 1px;
        }

        .key.black {
            width: 24px;
            height: 70px;
            background: linear-gradient(to bottom, #333 0%, #000000 100%);
            border: 1px solid #000;
            color: #fff;
            position: absolute;
            z-index: 2;
            font-size: 7px;
        }

        .key.white:active, .key.white.active {
            background: linear-gradient(to bottom, #00d4ff 0%, #0099cc 100%);
            transform: translateY(2px);
        }

        .key.black:active, .key.black.active {
            background: linear-gradient(to bottom, #00a0cc 0%, #006688 100%);
            transform: translateY(2px);
        }

        .key-label {
            font-size: 7px;
            opacity: 0.6;
        }

        /* Position black keys for 2 octaves */
        .key.black[data-note="C#1"] { left: 26px; }
        .key.black[data-note="D#1"] { left: 64px; }
        .key.black[data-note="F#1"] { left: 140px; }
        .key.black[data-note="G#1"] { left: 178px; }
        .key.black[data-note="A#1"] { left: 216px; }
        .key.black[data-note="C#2"] { left: 292px; }
        .key.black[data-note="D#2"] { left: 330px; }
        .key.black[data-note="F#2"] { left: 406px; }
        .key.black[data-note="G#2"] { left: 444px; }
        .key.black[data-note="A#2"] { left: 482px; }
    </style>
</head>
<body>
    <div class="synth-container">
        <div class="top-section">
            <div class="recording-section">
                <h2>ðŸŽ¤ Recording</h2>
                <div class="recording-buttons">
                    <button id="recordBtn">Record</button>
                    <button id="clearBtn">Clear</button>
                </div>
                <canvas id="waveformCanvas"></canvas>
                <div id="status" class="status">No audio recorded</div>
            </div>

            <div class="controls-section">
                <div class="control-group">
                    <label><span>Grain Size</span><span class="value" id="grainSizeValue">100ms</span></label>
                    <input type="range" id="grainSize" min="10" max="500" value="100" step="1">
                </div>
                
                <div class="control-group">
                    <label><span>Density</span><span class="value" id="densityValue">5</span></label>
                    <input type="range" id="density" min="1" max="20" value="5" step="1">
                </div>
                
                <div class="control-group">
                    <label><span>Position</span><span class="value" id="positionValue">0%</span></label>
                    <input type="range" id="position" min="0" max="100" value="0" step="0.1">
                </div>
                
                <div class="control-group">
                    <label><span>Spray</span><span class="value" id="sprayValue">0%</span></label>
                    <input type="range" id="spray" min="0" max="100" value="0" step="1">
                </div>
                
                <div class="control-group">
                    <label><span>Attack</span><span class="value" id="attackValue">10ms</span></label>
                    <input type="range" id="attack" min="1" max="10000" value="10" step="10">
                </div>
                
                <div class="control-group">
                    <label><span>Release</span><span class="value" id="releaseValue">500ms</span></label>
                    <input type="range" id="release" min="10" max="10000" value="500" step="10">
                </div>
                
                <div class="control-group">
                    <label><span>Sample Start</span><span class="value" id="sampleStartValue">0%</span></label>
                    <input type="range" id="sampleStart" min="0" max="100" value="0" step="0.1">
                </div>
                
                <div class="control-group">
                    <label><span>Sample End</span><span class="value" id="sampleEndValue">100%</span></label>
                    <input type="range" id="sampleEnd" min="0" max="100" value="100" step="0.1">
                </div>
                
                <div class="control-group">
                    <label><span>Volume</span><span class="value" id="volumeValue">70%</span></label>
                    <input type="range" id="volume" min="0" max="100" value="70" step="1">
                </div>
            </div>
        </div>

        <div class="keyboard-section">
            <div class="keyboard">
                <!-- Octave 1 -->
                <div class="key white" data-note="C1" data-key="a"><span>C<br><span class="key-label">A</span></span></div>
                <div class="key black" data-note="C#1" data-key="w"><span>C#<br><span class="key-label">W</span></span></div>
                <div class="key white" data-note="D1" data-key="s"><span>D<br><span class="key-label">S</span></span></div>
                <div class="key black" data-note="D#1" data-key="e"><span>D#<br><span class="key-label">E</span></span></div>
                <div class="key white" data-note="E1" data-key="d"><span>E<br><span class="key-label">D</span></span></div>
                <div class="key white" data-note="F1" data-key="f"><span>F<br><span class="key-label">F</span></span></div>
                <div class="key black" data-note="F#1" data-key="t"><span>F#<br><span class="key-label">T</span></span></div>
                <div class="key white" data-note="G1" data-key="g"><span>G<br><span class="key-label">G</span></span></div>
                <div class="key black" data-note="G#1" data-key="y"><span>G#<br><span class="key-label">Y</span></span></div>
                <div class="key white" data-note="A1" data-key="h"><span>A<br><span class="key-label">H</span></span></div>
                <div class="key black" data-note="A#1" data-key="u"><span>A#<br><span class="key-label">U</span></span></div>
                <div class="key white" data-note="B1" data-key="j"><span>B<br><span class="key-label">J</span></span></div>
                <!-- Octave 2 -->
                <div class="key white" data-note="C2" data-key="k"><span>C<br><span class="key-label">K</span></span></div>
                <div class="key black" data-note="C#2" data-key="o"><span>C#<br><span class="key-label">O</span></span></div>
                <div class="key white" data-note="D2" data-key="l"><span>D<br><span class="key-label">L</span></span></div>
                <div class="key black" data-note="D#2" data-key="p"><span>D#<br><span class="key-label">P</span></span></div>
                <div class="key white" data-note="E2" data-key=";"><span>E<br><span class="key-label">;</span></span></div>
                <div class="key white" data-note="F2" data-key="'"><span>F<br><span class="key-label">'</span></span></div>
                <div class="key black" data-note="F#2" data-key="]"><span>F#<br><span class="key-label">]</span></span></div>
                <div class="key white" data-note="G2" data-key="\\"><span>G<br><span class="key-label">\\</span></span></div>
                <div class="key black" data-note="G#2" data-key=""><span>G#</span></div>
                <div class="key white" data-note="A2" data-key="z"><span>A<br><span class="key-label">Z</span></span></div>
                <div class="key black" data-note="A#2" data-key="x"><span>A#<br><span class="key-label">X</span></span></div>
                <div class="key white" data-note="B2" data-key="c"><span>B<br><span class="key-label">C</span></span></div>
            </div>
        </div>
    </div>

    <script>
        // Web Audio API Setup
        let audioContext;
        let audioBuffer = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;

        // Track active notes
        const activeNotes = new Map();

        // UI Elements
        const recordBtn = document.getElementById('recordBtn');
        const clearBtn = document.getElementById('clearBtn');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const ctx = waveformCanvas.getContext('2d');
        const status = document.getElementById('status');

        // Parameter controls
        const grainSizeSlider = document.getElementById('grainSize');
        const densitySlider = document.getElementById('density');
        const positionSlider = document.getElementById('position');
        const spraySlider = document.getElementById('spray');
        const attackSlider = document.getElementById('attack');
        const releaseSlider = document.getElementById('release');
        const sampleStartSlider = document.getElementById('sampleStart');
        const sampleEndSlider = document.getElementById('sampleEnd');
        const volumeSlider = document.getElementById('volume');

        // Note to semitone mapping (C1 = 0, C2 = 12)
        const noteToSemitone = {
            'C1': 0, 'C#1': 1, 'D1': 2, 'D#1': 3, 'E1': 4, 'F1': 5,
            'F#1': 6, 'G1': 7, 'G#1': 8, 'A1': 9, 'A#1': 10, 'B1': 11,
            'C2': 12, 'C#2': 13, 'D2': 14, 'D#2': 15, 'E2': 16, 'F2': 17,
            'F#2': 18, 'G2': 19, 'G#2': 20, 'A2': 21, 'A#2': 22, 'B2': 23
        };

        // Keyboard mapping for 2 octaves
        const keyMap = {
            'a': 'C1', 'w': 'C#1', 's': 'D1', 'e': 'D#1', 'd': 'E1', 'f': 'F1',
            't': 'F#1', 'g': 'G1', 'y': 'G#1', 'h': 'A1', 'u': 'A#1', 'j': 'B1',
            'k': 'C2', 'o': 'C#2', 'l': 'D2', 'p': 'D#2', ';': 'E2', "'": 'F2',
            ']': 'F#2', '\\': 'G2', 'z': 'A2', 'x': 'A#2', 'c': 'B2'
        };

        // Initialize Audio Context
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // Update slider value displays
        function updateSliderDisplays() {
            document.getElementById('grainSizeValue').textContent = grainSizeSlider.value + 'ms';
            document.getElementById('densityValue').textContent = densitySlider.value;
            document.getElementById('positionValue').textContent = positionSlider.value + '%';
            document.getElementById('sprayValue').textContent = spraySlider.value + '%';
            
            const attackVal = parseFloat(attackSlider.value);
            document.getElementById('attackValue').textContent = attackVal >= 1000 
                ? (attackVal / 1000).toFixed(1) + 's' 
                : attackVal + 'ms';
            
            const releaseVal = parseFloat(releaseSlider.value);
            document.getElementById('releaseValue').textContent = releaseVal >= 1000 
                ? (releaseVal / 1000).toFixed(1) + 's' 
                : releaseVal + 'ms';
            
            document.getElementById('sampleStartValue').textContent = sampleStartSlider.value + '%';
            document.getElementById('sampleEndValue').textContent = sampleEndSlider.value + '%';
            document.getElementById('volumeValue').textContent = volumeSlider.value + '%';
        }

        // Add event listeners for sliders
        [grainSizeSlider, densitySlider, positionSlider, spraySlider, 
         attackSlider, releaseSlider, sampleStartSlider, sampleEndSlider, volumeSlider].forEach(slider => {
            slider.addEventListener('input', updateSliderDisplays);
        });

        // Recording functionality
        recordBtn.addEventListener('click', async () => {
            initAudioContext();
            
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];

                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        const arrayBuffer = await audioBlob.arrayBuffer();
                        audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        drawWaveform(audioBuffer);
                        status.textContent = `Done! ${audioBuffer.duration.toFixed(1)}s`;
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.textContent = 'Stop';
                    recordBtn.classList.add('recording');
                    status.textContent = 'Recording...';
                } catch (error) {
                    status.textContent = 'Mic access denied';
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                recordBtn.textContent = 'Record';
                recordBtn.classList.remove('recording');
            }
        });

        // Clear buffer
        clearBtn.addEventListener('click', () => {
            audioBuffer = null;
            audioChunks = [];
            ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            status.textContent = 'Buffer cleared';
        });

        // Draw waveform with sample start/end markers
        function drawWaveform(buffer) {
            const width = waveformCanvas.width = waveformCanvas.clientWidth;
            const height = waveformCanvas.height = waveformCanvas.clientHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            const data = buffer.getChannelData(0);
            const step = Math.ceil(data.length / width);
            const amp = height / 2;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, width, height);

            // Draw sample region
            const startX = (parseFloat(sampleStartSlider.value) / 100) * width;
            const endX = (parseFloat(sampleEndSlider.value) / 100) * width;
            ctx.fillStyle = 'rgba(0, 212, 255, 0.1)';
            ctx.fillRect(startX, 0, endX - startX, height);

            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 1;
            ctx.beginPath();

            for (let i = 0; i < width; i++) {
                let min = 1;
                let max = -1;
                for (let j = 0; j < step; j++) {
                    const value = data[(i * step) + j] || 0;
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
                
                const yMin = (1 + min) * amp;
                const yMax = (1 + max) * amp;

                if (i === 0) ctx.moveTo(i, yMax);
                ctx.lineTo(i, yMax);
                ctx.lineTo(i, yMin);
            }
            ctx.stroke();

            // Draw start/end lines
            ctx.strokeStyle = '#ff0844';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX, 0);
            ctx.lineTo(startX, height);
            ctx.moveTo(endX, 0);
            ctx.lineTo(endX, height);
            ctx.stroke();
        }

        // Update waveform when sample start/end changes
        sampleStartSlider.addEventListener('input', () => {
            if (audioBuffer) drawWaveform(audioBuffer);
        });
        sampleEndSlider.addEventListener('input', () => {
            if (audioBuffer) drawWaveform(audioBuffer);
        });

        // Create a single grain
        function createGrain(buffer, position, grainSizeSec, pitch, masterGainNode) {
            const source = audioContext.createBufferSource();
            const grainGain = audioContext.createGain();

            source.buffer = buffer;
            source.playbackRate.value = pitch;

            // Get sample region
            const sampleStart = parseFloat(sampleStartSlider.value) / 100;
            const sampleEnd = parseFloat(sampleEndSlider.value) / 100;
            const regionStart = sampleStart * buffer.duration;
            const regionDuration = (sampleEnd - sampleStart) * buffer.duration;

            const sprayAmount = parseFloat(spraySlider.value) / 100;
            const randomOffset = (Math.random() - 0.5) * sprayAmount * regionDuration;
            
            // Position within the sample region
            let startPos = regionStart + (position * regionDuration) + randomOffset;
            const maxStartTime = Math.max(regionStart, regionStart + regionDuration - grainSizeSec);
            startPos = Math.max(regionStart, Math.min(startPos, maxStartTime));

            const now = audioContext.currentTime;

            // Grain envelope
            grainGain.gain.setValueAtTime(0, now);
            grainGain.gain.linearRampToValueAtTime(1, now + 0.005);
            grainGain.gain.setValueAtTime(1, now + grainSizeSec - 0.005);
            grainGain.gain.linearRampToValueAtTime(0, now + grainSizeSec);

            source.connect(grainGain);
            grainGain.connect(masterGainNode);

            source.start(now, startPos, grainSizeSec);

            return { source, grainGain };
        }

        // Start playing a note (called on key DOWN)
        function startNote(note) {
            if (!audioBuffer) {
                status.textContent = 'Record audio first!';
                return;
            }

            if (activeNotes.has(note)) return;

            initAudioContext();

            const semitones = noteToSemitone[note];
            const pitch = Math.pow(2, semitones / 12);
            const volume = parseFloat(volumeSlider.value) / 100;
            const attackTime = parseFloat(attackSlider.value) / 1000;

            // Create master gain for this note
            const noteGain = audioContext.createGain();
            noteGain.connect(audioContext.destination);
            
            // Attack envelope
            const now = audioContext.currentTime;
            noteGain.gain.setValueAtTime(0.001, now);
            noteGain.gain.exponentialRampToValueAtTime(volume, now + attackTime);

            const grains = [];
            let isActive = true;

            const spawnGrain = () => {
                if (!isActive) return;

                const grainSize = parseFloat(grainSizeSlider.value) / 1000;
                const position = parseFloat(positionSlider.value) / 100;

                const grain = createGrain(audioBuffer, position, grainSize, pitch, noteGain);
                grains.push(grain);

                grain.source.onended = () => {
                    const idx = grains.indexOf(grain);
                    if (idx > -1) grains.splice(idx, 1);
                };
            };

            const getGrainInterval = () => {
                const grainSize = parseFloat(grainSizeSlider.value) / 1000;
                const density = parseInt(densitySlider.value);
                return (grainSize / density) * 1000;
            };

            spawnGrain();

            const intervalId = setInterval(() => {
                if (isActive) spawnGrain();
            }, getGrainInterval());

            activeNotes.set(note, {
                noteGain,
                grains,
                intervalId,
                isActive: true,
                setInactive: () => { isActive = false; }
            });
        }

        // Stop playing a note (called on key UP)
        function stopNote(note) {
            const noteData = activeNotes.get(note);
            if (!noteData) return;

            const { noteGain, grains, intervalId, setInactive } = noteData;
            const releaseTime = parseFloat(releaseSlider.value) / 1000;

            // Stop spawning new grains
            clearInterval(intervalId);
            setInactive();

            // Release envelope
            const now = audioContext.currentTime;
            const currentGain = noteGain.gain.value;
            
            noteGain.gain.cancelScheduledValues(now);
            noteGain.gain.setValueAtTime(currentGain, now);
            noteGain.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);

            activeNotes.delete(note);

            // Cleanup after release completes
            setTimeout(() => {
                try {
                    noteGain.disconnect();
                } catch (e) {}
                grains.forEach(g => {
                    try {
                        g.source.stop();
                        g.source.disconnect();
                        g.grainGain.disconnect();
                    } catch (e) {}
                });
            }, (releaseTime * 1000) + 200);
        }

        // Keyboard event handlers
        const keys = document.querySelectorAll('.key');
        const pressedKeys = new Set();

        keys.forEach(key => {
            key.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const note = key.dataset.note;
                key.classList.add('active');
                startNote(note);
            });

            key.addEventListener('mouseup', (e) => {
                e.preventDefault();
                const note = key.dataset.note;
                key.classList.remove('active');
                stopNote(note);
            });

            key.addEventListener('mouseleave', (e) => {
                const note = key.dataset.note;
                if (key.classList.contains('active')) {
                    key.classList.remove('active');
                    stopNote(note);
                }
            });

            key.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const note = key.dataset.note;
                key.classList.add('active');
                startNote(note);
            }, { passive: false });

            key.addEventListener('touchend', (e) => {
                e.preventDefault();
                const note = key.dataset.note;
                key.classList.remove('active');
                stopNote(note);
            }, { passive: false });

            key.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                const note = key.dataset.note;
                key.classList.remove('active');
                stopNote(note);
            }, { passive: false });
        });

        // Computer keyboard support
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const key = e.key.toLowerCase();
            
            if (keyMap[key]) {
                e.preventDefault();
                e.stopPropagation();
                
                if (e.repeat || pressedKeys.has(key)) return;
                
                pressedKeys.add(key);
                const note = keyMap[key];
                const keyElement = document.querySelector(`.key[data-key="${key}"]`);
                if (keyElement) {
                    keyElement.classList.add('active');
                    startNote(note);
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            
            if (keyMap[key]) {
                e.preventDefault();
                e.stopPropagation();
                
                pressedKeys.delete(key);
                const note = keyMap[key];
                const keyElement = document.querySelector(`.key[data-key="${key}"]`);
                if (keyElement) {
                    keyElement.classList.remove('active');
                    stopNote(note);
                }
            }
        });

        // Initialize
        updateSliderDisplays();

        // Prevent context menu
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('dragstart', (e) => e.preventDefault());
        
        // Prevent scrolling
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

        // Force landscape orientation check
        if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(() => {});
        }
    </script>
</body>
</html>