This version includes a specific fix for the iOS Audio Context (explicitly creating and resuming it inside a touch event), rebuilds the keyboard logic to ensure it renders correctly on desktop (using a standard flexbox approach that prevents key collapse), and verifies the LFO depth math.

```html name=granular-synth-final-v2.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Granular LFO Synth</title>
    <style>
        :root {
            --bg: #121216;
            --panel: #1e1e24;
            --accent: #00d4ff;
            --accent-dim: rgba(0, 212, 255, 0.1);
            --lfo: #ffcc00;
            --rec: #ff3366;
            --text: #ddd;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            position: fixed;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column;
        }

        /* Overlay */
        .overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #orientation-overlay { display: none; }
        
        @media screen and (orientation: portrait) {
            #orientation-overlay { display: flex; }
            .app-container { display: none !important; }
        }

        .start-btn {
            margin-top: 20px; padding: 15px 40px; border-radius: 30px;
            background: var(--accent); color: #000; font-size: 18px; font-weight: bold; border: none;
        }

        /* Layout */
        .app-container {
            display: flex; flex-direction: column; height: 100%; width: 100%; padding: 4px; gap: 4px;
        }

        .top-row {
            flex: 1; display: flex; gap: 4px; min-height: 0; /* allows child scroll */
        }

        /* Sidebar */
        .sidebar {
            width: 150px; display: flex; flex-direction: column; gap: 4px;
        }

        .panel {
            background: var(--panel); border: 1px solid #333; border-radius: 4px; padding: 6px;
            display: flex; flex-direction: column; gap: 4px;
        }
        .rec-panel { flex: 0 0 auto; }
        .lfo-panel { flex: 0 0 auto; border-color: #665500; }

        .panel-label { font-size: 10px; font-weight: bold; color: var(--accent); text-transform: uppercase; display: flex; justify-content: space-between; }
        .lfo-label { color: var(--lfo); }

        .btn-row { display: flex; gap: 4px; }
        .btn-act { 
            flex: 1; background: #333; color: #fff; border: none; border-radius: 2px; 
            padding: 8px 0; font-size: 10px; font-weight: bold; 
        }
        #recBtn.recording { background: var(--rec); animation: pulse 1s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }

        canvas { width: 100%; height: 40px; background: #000; border: 1px solid #444; border-radius: 2px; }
        .status { font-size: 9px; color: #666; text-align: center; }

        /* LFO Controls */
        .lfo-row { display: flex; align-items: center; gap: 4px; height: 20px; }
        .lfo-row label { font-size: 9px; width: 25px; color: #888; }
        .lfo-row input { flex: 1; }
        .lfo-row select { flex: 1; background: #222; color: var(--lfo); border: none; font-size: 10px; height: 100%; }

        /* Controls Grid */
        .controls-grid {
            flex: 1;
            background: var(--panel); border: 1px solid #333; border-radius: 4px; padding: 4px;
            overflow-y: auto; -webkit-overflow-scrolling: touch;
            display: grid; grid-template-columns: repeat(4, 1fr); 
            grid-auto-rows: min-content; gap: 4px;
        }

        .ctrl-cell {
            background: rgba(0,0,0,0.2); padding: 4px; border-radius: 3px;
            display: flex; flex-direction: column; gap: 2px;
        }
        .ctrl-cell.hl { background: var(--accent-dim); }

        .ctrl-head { display: flex; justify-content: space-between; align-items: center; }
        .ctrl-name { font-size: 9px; font-weight: bold; color: #aaa; }
        .ctrl-val { font-size: 9px; color: var(--accent); font-family: monospace; }
        
        .ctrl-body { display: flex; align-items: center; gap: 2px; height: 22px; }
        
        .mini-btn {
            width: 18px; height: 100%; border: 1px solid #444; background: #222; 
            color: #666; font-size: 8px; font-weight: bold; border-radius: 2px; padding: 0;
        }
        .mini-btn.active-m { background: var(--lfo); color: #000; border-color: var(--lfo); }
        .mini-btn.active-i { background: #ff4400; color: #fff; border-color: #ff4400; }

        /* Range Sliders */
        input[type=range] {
            -webkit-appearance: none; background: transparent; width: 100%; flex: 1; margin: 0;
        }
        input[type=range]::-webkit-slider-runnable-track {
            height: 4px; background: #333; border-radius: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; 
            background: var(--accent); margin-top: -6px; border: 1px solid #000;
        }
        .lfo-slider::-webkit-slider-thumb { background: var(--lfo); }

        /* Keyboard */
        .keyboard-wrapper {
            height: 90px; flex-shrink: 0;
            background: var(--panel); border: 1px solid #333; border-radius: 4px;
            padding: 4px 10px; position: relative;
        }
        .keys-flex {
            display: flex; width: 100%; height: 100%; position: relative;
        }
        .key-white {
            flex: 1; background: #e0e0e0; margin: 0 1px; border-radius: 0 0 3px 3px;
            position: relative; z-index: 1; display: flex; align-items: flex-end; justify-content: center;
            padding-bottom: 4px; font-size: 9px; color: #333; font-weight: bold;
        }
        .key-black {
            position: absolute; top: 0; height: 60%; width: 5%; 
            background: #000; z-index: 10; border-radius: 0 0 2px 2px;
            pointer-events: auto; /* Ensure clickable */
        }
        .key-white.active { background: var(--accent); transform: scaleY(0.98); transform-origin: top; }
        .key-black.active { background: var(--accent); }

        /* Black Key Positions (Left %) */
        /* 14 white keys. 1/14 â‰ˆ 7.14%. */
        /* C#1 between C1(0) and D1(1). Center approx 5% */
        .bk-0 { left: 4.5%; }   /* C#1 */
        .bk-1 { left: 11.5%; }  /* D#1 */
        .bk-2 { left: 26.0%; }  /* F#1 */
        .bk-3 { left: 33.0%; }  /* G#1 */
        .bk-4 { left: 40.0%; }  /* A#1 */
        .bk-5 { left: 54.5%; }  /* C#2 */
        .bk-6 { left: 61.5%; }  /* D#2 */
        .bk-7 { left: 76.0%; }  /* F#2 */
        .bk-8 { left: 83.0%; }  /* G#2 */
        .bk-9 { left: 90.0%; }  /* A#2 */

    </style>
</head>
<body>

    <div id="orientation-overlay" class="overlay">
        <h1 style="color:var(--accent)">Rotate Device</h1>
    </div>

    <div id="start-overlay" class="overlay">
        <h1 style="color:var(--accent)">Granular LFO</h1>
        <p style="color:#aaa; font-size: 12px; margin-top: 10px">Turn off Silent Mode</p>
        <button id="startBtn" class="start-btn">TAP TO START</button>
    </div>

    <div class="app-container">
        <div class="top-row">
            <div class="sidebar">
                <!-- Recording -->
                <div class="panel rec-panel">
                    <div class="panel-label">Source In</div>
                    <div class="btn-row">
                        <button id="recBtn" class="btn-act">REC</button>
                        <button id="clrBtn" class="btn-act">CLR</button>
                    </div>
                    <canvas id="waveCanvas"></canvas>
                    <div id="status" class="status">Waiting</div>
                </div>

                <!-- LFO Master -->
                <div class="panel lfo-panel">
                    <div class="panel-label lfo-label">LFO Master</div>
                    <div class="lfo-row">
                        <select id="lfoShape">
                            <option value="sine">Sine</option>
                            <option value="saw">Saw</option>
                            <option value="sq">Square</option>
                            <option value="tri">Tri</option>
                        </select>
                    </div>
                    <div class="lfo-row">
                        <label>Rate</label>
                        <input type="range" id="lfoRate" class="lfo-slider" min="10" max="400" value="120">
                    </div>
                    <div class="lfo-row">
                        <label>Depth</label>
                        <input type="range" id="lfoDepth" class="lfo-slider" min="0" max="100" value="50">
                    </div>
                </div>
            </div>

            <!-- Controls -->
            <div class="controls-grid" id="grid"></div>
        </div>

        <!-- Keyboard -->
        <div class="keyboard-wrapper">
            <div class="keys-flex" id="kbd">
                <!-- White Keys -->
                <div class="key-white" data-n="C1">C</div>
                <div class="key-white" data-n="D1">D</div>
                <div class="key-white" data-n="E1">E</div>
                <div class="key-white" data-n="F1">F</div>
                <div class="key-white" data-n="G1">G</div>
                <div class="key-white" data-n="A1">A</div>
                <div class="key-white" data-n="B1">B</div>
                <div class="key-white" data-n="C2">C</div>
                <div class="key-white" data-n="D2">D</div>
                <div class="key-white" data-n="E2">E</div>
                <div class="key-white" data-n="F2">F</div>
                <div class="key-white" data-n="G2">G</div>
                <div class="key-white" data-n="A2">A</div>
                <div class="key-white" data-n="B2">B</div>
                
                <!-- Black Keys -->
                <div class="key-black bk-0" data-n="C#1"></div>
                <div class="key-black bk-1" data-n="D#1"></div>
                <div class="key-black bk-2" data-n="F#1"></div>
                <div class="key-black bk-3" data-n="G#1"></div>
                <div class="key-black bk-4" data-n="A#1"></div>
                <div class="key-black bk-5" data-n="C#2"></div>
                <div class="key-black bk-6" data-n="D#2"></div>
                <div class="key-black bk-7" data-n="F#2"></div>
                <div class="key-black bk-8" data-n="G#2"></div>
                <div class="key-black bk-9" data-n="A#2"></div>
            </div>
        </div>
    </div>

    <script>
        // --- Data ---
        const PARAMS = [
            { id: 'start', label: 'Start', min: 0, max: 100, val: 0, unit: '%', hl: true },
            { id: 'end', label: 'End', min: 0, max: 100, val: 100, unit: '%', hl: true },
            { id: 'grain', label: 'Size', min: 10, max: 500, val: 100, unit: 'ms' },
            { id: 'dens', label: 'Dens', min: 1, max: 50, val: 15, unit: '' },
            { id: 'pos', label: 'Scan', min: 0, max: 100, val: 0, unit: '%', hl: true },
            { id: 'spray', label: 'Spray', min: 0, max: 100, val: 10, unit: '' },
            { id: 'atk', label: 'Atk', min: 1, max: 200, val: 20, unit: 'ms' },
            { id: 'rel', label: 'Rel', min: 1, max: 500, val: 100, unit: 'ms' },
            { id: 'pvar', label: 'P.Rnd', min: 0, max: 100, val: 0, unit: '' },
            { id: 'width', label: 'Width', min: 0, max: 100, val: 80, unit: '%' },
            { id: 'verb', label: 'Verb', min: 0, max: 100, val: 25, unit: '%' },
            { id: 'vol', label: 'Vol', min: 0, max: 100, val: 80, unit: '%' },
        ];

        const NOTES = {
            'C1':32.7,'C#1':34.6,'D1':36.7,'D#1':38.9,'E1':41.2,'F1':43.7,'F#1':46.2,'G1':49.0,'G#1':51.9,'A1':55.0,'A#1':58.3,'B1':61.7,
            'C2':65.4,'C#2':69.3,'D2':73.4,'D#2':77.8,'E2':82.4,'F2':87.3,'F#2':92.5,'G2':98.0,'G#2':103.8,'A2':110.0,'A#2':116.5,'B2':123.5
        };

        // --- State ---
        let actx = null;
        let buf = null;
        let isRec = false;
        let mediaRec = null;
        let recChunks = [];
        
        // Nodes
        let master, rev, dry, wet;

        // LFO
        let lfo = { ph: 0, lastT: 0, val: 0, bpm: 120, depth: 0.5, shape: 'sine' };

        // Controls { id: { base, mod, inv, curr } }
        let ctrlState = {};
        let activeVoices = new Map(); // note -> timeoutID

        // --- Init ---
        function init() {
            // Build UI
            const grid = document.getElementById('grid');
            PARAMS.forEach(p => {
                ctrlState[p.id] = { base: p.val, mod: false, inv: false, curr: p.val, min: p.min, max: p.max };
                
                const el = document.createElement('div');
                el.className = `ctrl-cell ${p.hl?'hl':''}`;
                el.innerHTML = `
                    <div class="ctrl-head">
                        <span class="ctrl-name">${p.label}</span>
                        <span class="ctrl-val" id="disp_${p.id}">${p.val}${p.unit}</span>
                    </div>
                    <div class="ctrl-body">
                        <input type="range" id="sl_${p.id}" min="${p.min}" max="${p.max}" value="${p.val}">
                        <button class="mini-btn" id="bm_${p.id}">M</button>
                        <button class="mini-btn" id="bi_${p.id}">I</button>
                    </div>
                `;
                grid.appendChild(el);

                // Listeners
                const sl = el.querySelector(`#sl_${p.id}`);
                const bm = el.querySelector(`#bm_${p.id}`);
                const bi = el.querySelector(`#bi_${p.id}`);

                sl.addEventListener('input', e => {
                    ctrlState[p.id].base = parseFloat(e.target.value);
                    if(!ctrlState[p.id].mod) updateDisplay(p.id, p.unit);
                    if(p.id==='start'||p.id==='end') drawWave();
                });

                bm.addEventListener('click', () => {
                    ctrlState[p.id].mod = !ctrlState[p.id].mod;
                    bm.classList.toggle('active-m', ctrlState[p.id].mod);
                });

                bi.addEventListener('click', () => {
                    ctrlState[p.id].inv = !ctrlState[p.id].inv;
                    bi.classList.toggle('active-i', ctrlState[p.id].inv);
                });
            });

            // LFO Listeners
            document.getElementById('lfoRate').addEventListener('input', e => lfo.bpm = parseFloat(e.target.value));
            document.getElementById('lfoDepth').addEventListener('input', e => lfo.depth = parseFloat(e.target.value)/100);
            document.getElementById('lfoShape').addEventListener('change', e => lfo.shape = e.target.value);

            // Keys Listener
            const kbd = document.getElementById('kbd');
            const handleNote = (e, down) => {
                if(e.target.hasAttribute('data-n')) {
                    e.preventDefault();
                    const n = e.target.getAttribute('data-n');
                    if(down) {
                        e.target.classList.add('active');
                        e.target.setPointerCapture(e.pointerId);
                        startVoice(n);
                    } else {
                        e.target.classList.remove('active');
                        e.target.releasePointerCapture(e.pointerId);
                        stopVoice(n);
                    }
                }
            };
            
            kbd.addEventListener('pointerdown', e => handleNote(e, true));
            kbd.addEventListener('pointerup', e => handleNote(e, false));
            kbd.addEventListener('pointercancel', e => handleNote(e, false));
            kbd.addEventListener('pointerleave', e => {
                if(e.target.classList.contains('active')) handleNote(e, false);
            });
        }

        function updateDisplay(id, unit) {
            const el = document.getElementById(`disp_${id}`);
            let val = ctrlState[id].curr;
            if(val % 1 !== 0) val = val.toFixed(1);
            else val = Math.round(val);
            el.innerText = val + unit;
            el.style.color = ctrlState[id].mod ? 'var(--lfo)' : 'var(--accent)';
        }

        // --- Audio Start ---
        document.getElementById('startBtn').addEventListener('click', async () => {
            const AC = window.AudioContext || window.webkitAudioContext;
            if(!actx) actx = new AC();
            
            // Resume if suspended (iOS requirement)
            if(actx.state === 'suspended') await actx.resume();

            // Play Silent Buffer (Unlock Engine)
            const b = actx.createBuffer(1, 1, 22050);
            const s = actx.createBufferSource();
            s.buffer = b;
            s.connect(actx.destination);
            s.start(0);

            // Setup Graph
            master = actx.createGain();
            master.connect(actx.destination);

            rev = actx.createConvolver();
            // Impulse
            const rate = actx.sampleRate;
            const len = rate * 2.0;
            const imp = actx.createBuffer(2, len, rate);
            for(let c=0;c<2;c++) {
                const d = imp.getChannelData(c);
                for(let i=0;i<len;i++) d[i] = (Math.random()*2-1)*Math.pow(1-i/len, 3);
            }
            rev.buffer = imp;

            dry = actx.createGain();
            wet = actx.createGain();
            
            dry.connect(master);
            rev.connect(wet);
            wet.connect(master);

            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('status').innerText = "Engine Ready";

            lfo.lastT = actx.currentTime;
            requestAnimationFrame(loop);
        });

        // --- Loop ---
        function loop() {
            if(!actx) return;
            const now = actx.currentTime;
            const dt = now - lfo.lastT;
            lfo.lastT = now;

            // Update LFO
            lfo.ph += dt * (lfo.bpm/60) * 2 * Math.PI;
            const p = lfo.ph % (2 * Math.PI);
            
            let raw = 0;
            if(lfo.shape === 'sine') raw = Math.sin(p);
            else if(lfo.shape === 'sq') raw = p < Math.PI ? 1 : -1;
            else if(lfo.shape === 'saw') raw = (p/(2*Math.PI))*2 - 1;
            else if(lfo.shape === 'tri') {
                const n = p/(2*Math.PI);
                raw = n < 0.5 ? 4*n - 1 : 3 - 4*n;
            }
            lfo.val = raw;

            // Modulate
            PARAMS.forEach(param => {
                const st = ctrlState[param.id];
                let val = st.base;
                if(st.mod) {
                    const range = st.max - st.min;
                    let factor = lfo.val;
                    if(st.inv) factor *= -1;
                    val += factor * lfo.depth * (range * 0.5);
                    val = Math.max(st.min, Math.min(st.max, val));
                    updateDisplay(param.id, param.unit);
                }
                st.curr = val;
            });

            // Update FX
            if(master) {
                const v = ctrlState['vol'].curr / 100;
                const r = ctrlState['verb'].curr / 100;
                master.gain.value = v;
                dry.gain.value = 1.0 - (r * 0.4);
                wet.gain.value = r;
            }

            // Redraw Markers if modulated
            if(ctrlState['start'].mod || ctrlState['end'].mod) drawWave();

            requestAnimationFrame(loop);
        }

        // --- Rec ---
        document.getElementById('recBtn').addEventListener('click', async () => {
            if(!actx) return;
            const btn = document.getElementById('recBtn');
            
            if(isRec) {
                mediaRec.stop();
                isRec = false;
                btn.classList.remove('recording');
                btn.innerText = "REC";
            } else {
                if(actx.state === 'suspended') await actx.resume();
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { echoCancellation:false, autoGainControl:false, noiseSuppression:false } 
                    });
                    
                    let opts = {};
                    if(MediaRecorder.isTypeSupported('audio/webm')) opts={mimeType:'audio/webm'};
                    else if(MediaRecorder.isTypeSupported('audio/mp4')) opts={mimeType:'audio/mp4'};

                    mediaRec = new MediaRecorder(stream, opts);
                    recChunks = [];
                    mediaRec.ondataavailable = e => recChunks.push(e.data);
                    mediaRec.onstop = async () => {
                        const blob = new Blob(recChunks, {type: mediaRec.mimeType});
                        const ab = await blob.arrayBuffer();
                        actx.decodeAudioData(ab, b => {
                            buf = b;
                            drawWave();
                            document.getElementById('status').innerText = `Buffer: ${b.duration.toFixed(2)}s`;
                        }, e => alert("Decode Err: " + e));
                        stream.getTracks().forEach(t=>t.stop());
                    };
                    mediaRec.start();
                    isRec = true;
                    btn.classList.add('recording');
                    btn.innerText = "STOP";
                    document.getElementById('status').innerText = "Recording...";
                } catch(e) {
                    alert("Mic Error: " + e.message);
                }
            }
        });

        document.getElementById('clrBtn').addEventListener('click', () => {
            buf = null; drawWave();
            document.getElementById('status').innerText = "Cleared";
        });

        function drawWave() {
            const c = document.getElementById('waveCanvas');
            const ctx = c.getContext('2d');
            const w = c.width = c.clientWidth;
            const h = c.height = c.clientHeight;
            
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
            if(!buf) return;

            const d = buf.getChannelData(0);
            const step = Math.ceil(d.length/w);
            const amp = h/2;

            ctx.beginPath(); ctx.strokeStyle='#0ff';
            for(let i=0; i<w; i++) {
                let mn=1, mx=-1;
                for(let j=0; j<step; j++) {
                    const v = d[i*step+j];
                    if(v<mn)mn=v; if(v>mx)mx=v;
                }
                ctx.moveTo(i, (1+mn)*amp);
                ctx.lineTo(i, (1+mx)*amp);
            }
            ctx.stroke();

            // Markers
            const s = ctrlState['start'].curr/100;
            const e = ctrlState['end'].curr/100;
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(0,0,w*s,h);
            ctx.fillRect(w*e,0,w*(1-e),h);
            ctx.fillStyle = '#f00';
            ctx.fillRect(w*s,0,2,h);
            ctx.fillRect(w*e,0,2,h);
        }

        // --- Engine ---
        function playGrain(note) {
            if(!buf) return;
            
            let s = ctrlState['start'].curr/100;
            let e = ctrlState['end'].curr/100;
            if(s>e) [s,e]=[e,s];
            
            const dur = buf.duration;
            const t1 = dur * s;
            const t2 = dur * e;
            const win = t2 - t1;
            if(win <= 0.01) return;

            // Params
            const gSize = ctrlState['grain'].curr/1000;
            const pos = ctrlState['pos'].curr/100;
            const spr = ctrlState['spray'].curr/100;
            const atk = ctrlState['atk'].curr/1000;
            const rel = ctrlState['rel'].curr/1000;
            const pVar = ctrlState['pvar'].curr/100;
            const width = ctrlState['width'].curr/100;

            // Pos
            let offset = t1 + (pos * win);
            offset += (Math.random()*2-1) * spr * win * 0.5;
            offset = Math.max(t1, Math.min(t2-gSize, offset));

            // Pitch
            let rate = (NOTES[note] || 65.4) / 65.4; // Base C2
            rate *= (1 + (Math.random()*2-1)*pVar*0.1);

            // Graph
            const src = actx.createBufferSource();
            src.buffer = buf;
            src.playbackRate.value = rate;
            
            const env = actx.createGain();
            const pan = actx.createStereoPanner();
            pan.pan.value = (Math.random()*2-1)*width;

            src.connect(env).connect(pan);
            pan.connect(dry);
            pan.connect(rev);

            const t = actx.currentTime;
            env.gain.setValueAtTime(0, t);
            env.gain.linearRampToValueAtTime(1, t + atk);
            env.gain.linearRampToValueAtTime(0, t + gSize);

            src.start(t, offset, gSize);
            src.stop(t + gSize + 0.1);
        }

        function startVoice(note) {
            if(!buf || activeVoices.has(note)) return;
            
            function tick() {
                if(!activeVoices.has(note)) return;
                playGrain(note);
                let d = ctrlState['dens'].curr;
                if(d<1) d=1;
                activeVoices.set(note, setTimeout(tick, 1000/d));
            }
            tick();
        }

        function stopVoice(note) {
            if(activeVoices.has(note)) {
                clearTimeout(activeVoices.get(note));
                activeVoices.delete(note);
            }
        }

        // Run
        init();

    </script>
</body>
</html>
```
